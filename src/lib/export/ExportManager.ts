
import * as THREE from 'three';
import { jsPDF } from 'jspdf';
import { GLTFExporter } from 'three/examples/jsm/exporters/GLTFExporter.js';
import { DesignIntent } from '../schemas/designIntent';
import { GeneratedVariant } from '../variants/variantGenerator';

export class ExportManager {
    static downloadGLTF(mesh: THREE.Object3D, filename: string) {
        const exporter = new GLTFExporter();
        exporter.parse(
            mesh,
            (gltf) => {
                const output = JSON.stringify(gltf, null, 2);
                this.triggerDownload(output, filename + '.gltf', 'model/gltf+json');
            },
            (error) => {
                console.error('An error happened during GLTF export', error);
            },
            { binary: false }
        );
    }

    static downloadPDF(intent: DesignIntent, variant: GeneratedVariant, filename: string) {
        const doc = new jsPDF();

        // Header
        doc.setFontSize(20);
        doc.text("ENGINEERING REPORT", 20, 20);
        doc.setFontSize(10);
        doc.text(`Generated by Mec Agent | ${new Date().toISOString()}`, 20, 30);

        // Intent
        doc.setFontSize(14);
        doc.text("1. DESIGN INTENT", 20, 45);
        doc.setFontSize(10);
        let y = 55;
        doc.text(`Part ID: ${intent.part_id}`, 25, y); y += 6;
        doc.text(`Material: ${intent.materials.join(', ')}`, 25, y); y += 6;

        // Params
        doc.text("Parameters:", 25, y); y += 6;
        Object.entries(intent.parameters).forEach(([k, v]) => {
            if (typeof v !== 'object') {
                doc.text(` - ${k}: ${v}`, 30, y);
                y += 5;
            }
        });

        // Engineering Analysis
        y += 10;
        doc.setFontSize(14);
        doc.text("2. ANALYSIS", 20, y); y += 10;
        doc.setFontSize(10);
        doc.text(`Variant: ${variant.displayName}`, 25, y); y += 6;
        // Check if metrics exist (it might be metadata in generated variant)
        const mass = (variant as any).metrics?.mass_g || (variant as any).metadata?.mass_g;
        doc.text(`Mass: ${mass?.toFixed(1) || 'N/A'} g`, 25, y); y += 6;
        doc.text(`Cost Index: ${(variant as any).metrics?.cost_score || 'N/A'}`, 25, y); y += 6;

        doc.save(filename + '.pdf');
    }

    /**
     * Downloads the current Geometry as an ASCII STL file.
     * @param mesh The THREE.Mesh or THREE.Group to export
     * @param filename Desired filename
     */
    static downloadSTL(mesh: THREE.Object3D, filename: string) {
        const stlString = this.generateSTL(mesh);
        this.triggerDownload(stlString, filename + '.stl', 'text/plain');
    }

    /**
     * Downloads the Design Intent and Variant parameters as JSON.
     * @param intent The design intent
     * @param variant The generated variant
     * @param filename Desired filename
     */
    static downloadJSON(intent: DesignIntent, variant: GeneratedVariant, filename: string) {
        const data = JSON.stringify({
            metadata: {
                exportedAt: new Date().toISOString(),
                generator: "AIES_Local_Engine_v1"
            },
            intent,
            variant
        }, null, 2);
        this.triggerDownload(data, filename + '.json', 'application/json');
    }

    private static triggerDownload(content: string, filename: string, mimeType: string) {
        const blob = new Blob([content], { type: mimeType });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        document.body.appendChild(link); // Required for Firefox
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
    }

    // Simple ASCII STL Generator
    private static generateSTL(root: THREE.Object3D): string {
        let output = 'solid exported\n';

        root.traverse((child) => {
            if (child instanceof THREE.Mesh) {
                const geometry = child.geometry;
                const matrixWorld = child.matrixWorld;

                if (geometry.isBufferGeometry) {
                    const pos = geometry.getAttribute('position');
                    // Check if indexed
                    const index = geometry.getIndex();

                    const vA = new THREE.Vector3();
                    const vB = new THREE.Vector3();
                    const vC = new THREE.Vector3();
                    const normal = new THREE.Vector3();

                    // Helper to process triangle
                    const processTriangle = (a: number, b: number, c: number) => {
                        vA.fromBufferAttribute(pos, a).applyMatrix4(matrixWorld);
                        vB.fromBufferAttribute(pos, b).applyMatrix4(matrixWorld);
                        vC.fromBufferAttribute(pos, c).applyMatrix4(matrixWorld);

                        // Compute face normal
                        const cb = new THREE.Vector3().subVectors(vC, vB);
                        const ab = new THREE.Vector3().subVectors(vA, vB);
                        cb.cross(ab).normalize();

                        output += `facet normal ${cb.x} ${cb.y} ${cb.z}\n`;
                        output += 'outer loop\n';
                        output += `vertex ${vA.x} ${vA.y} ${vA.z}\n`;
                        output += `vertex ${vB.x} ${vB.y} ${vB.z}\n`;
                        output += `vertex ${vC.x} ${vC.y} ${vC.z}\n`;
                        output += 'endloop\n';
                        output += 'endfacet\n';
                    };

                    if (index) {
                        for (let i = 0; i < index.count; i += 3) {
                            processTriangle(index.getX(i), index.getY(i), index.getZ(i));
                        }
                    } else {
                        for (let i = 0; i < pos.count; i += 3) {
                            processTriangle(i, i + 1, i + 2);
                        }
                    }
                }
            }
        });

        output += 'endsolid exported\n';
        return output;
    }
}
